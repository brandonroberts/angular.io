block includes
  include ../_util-fns

:marked
  **Observables** provided by the Reactive Extensions for Javascript (RxJS) library provide applications with an extensive API
  for handling asynchronous and event-based values produced over time.

  An application is made up of many different streams of information. Whether it be user input into
  a form, navigating from one route another, making an HTTP request to fetch some data, updating the application view with
  new data as its received, or many other examples, each of these events happen over time. Observables provide a interface to
  handle the many different sources of events and help to transform these events as they flow throughout an application.

  This guide will serve as a reference for common uses cases for Observables in an Angular application
  and how Observables are used and provided by the Angular framework.

  ## Table of Contents
  * [The Observable](#definition "")
  * [Observables and Promises](#observables-vs-promises "")
  * [Using Operators](#operators "")
  * [Managing Subscriptions](#managing-subscriptions "")
  * [Sharing Data](#sharing-data "")
  * [Error Handling](#error-handling "")
  * [Framework APIs](#framework-apis "")
  * [Stream Integration](#stream-integration "")
  * [Further Reading](#further-reading "")

h3#definition The Observable: a function at its core

:marked
  An Observable, simply put, is a specific type of function with a specific purpose. Itâ€™s a function that accepts an `Observer` to produce values and
  returns a function for cancellation. It represents an action that can be performed. This action may be performed right now, or at some point
  in the future. An action can be anything, from simply "return a constant", "make an HTTP request" or "navigate to another page".

  Angular makes extensive use of Observables internally and externally through its APIs to provide you
  with built-in streams to use in your Angular application. These APIs also manage their provided Observables
  efficiently. This means you don't need to unsubscribe from these provided Observables as their subscriptions
  are managed locally and will be destroyed when your components are destroyed. Observable streams are made available through the HTTP client,
  reactive forms, the router and view querying APIs.

  Using Observables starts with an understanding of the basic principles, in which there are a wealth of resources that cover these in-depth. You should
  become more familiar with these principles, as it will help you with how to use these concepts in your Angular application. Below are a few resources
  to guide you in the concepts of an Observable and reactivity in general.

  * [Learning Observable By Building Observable](https://medium.com/@benlesh/learning-observable-by-building-observable-d5da57405d87#.3lun8dyt7)
  * [Thinking Reactively](https://www.youtube.com/watch?v=3LKMwkuK0ZE)
  * [RxJS Official Documentation](http://reactivex.io/rxjs/)

h3#observables-vs-promises Observables and Promises: More different than alike

:marked
  RxJS and Observables have been around for a long time, and they aren't the first concept of handling asynchronous events. Before Observables became more prevalent,
  the `Promise` was the primary way of handling asynchronous events. Promises and Observables share some similarities as they both handle asynchronous events,
  both implement a function to handle execution and error handling, but they are more different then alike.

  ***Promises***
  * Always eagerly evaluated
  * Produce a value/error once
  * Cannot be composed
  * Are always resolved/rejected asynchronously
  * Are always multicast to multiple receivers

  ***Observables***
  * Can be evaluated lazily
  * Produce multiple values/errors
  * Can be composed
  * Resolve synchronously/asynchronously
  * Multicast when needed using a Subject

  One of the strengths of Observables is producing and handling values over time, which is something a Promise wasn't designed to do. Observables also provide mechanisms
  for easy cancellation, retrying upon failure and transformations. Observables include a rich library of operators, along with the extensibility to provide a more powerful
  tool to handle the various streams of events in an application. So does this mean Promises are no longer needed? Absolutely not. Promises will continue to serve a purpose as
  the right tool for the job in some situations.

h3#operators Operators: Import them and use them

:marked
  Operators are pure functions that extend the Observable interface, allow you to perform an action against the Observable
  and return a new Observable. An Observable comes with very few built-in operators and the rest of the operators are
  added to the Observable on demand. There are multiple approaches to make these operators available for use.
  One approach is to import the entire RxJS library.

+makeExcerpt('src/app/heroes-filtered.component.1.ts', 'import-all')

:marked
  This is the **least recommended** method, as it brings in **all** the Observables operators,
  even ones you never use. While convenient, this method is inefficient and can greatly impact the size of your application,
  which is always a concern. This method is mainly reserved for prototyping and testing, where such concerns are less important.

  The second method is to import operators selectively by patching the Observable prototype. This allows you to chain
  operators together, as each operator returns a new Observable. Below is an example of importing the `filter` and `do` operators.
  The `filter` operator filters elements produced by an Observable based on a predicate function that returns a boolean. The `do` operator
  provides the Observable value to perform an arbitrary action, such as console logging.

+makeExcerpt('src/app/heroes-filtered.component.1.ts', 'operator-import')

:marked
  Had you not imported these common operators before using them with the Observable returned by `getHeroes`,
  the Observable would fail to perform these actions as these functions don't exist on the Observable instance yet.

  Another common example is two components with incomplete operator imports. Both files have components that use Observable operators
  but only one file imports the operators it needs. Interestingly enough if you load the component with the imported operators first and then
  load the second component, everything works fine. Conversely, loading the component without the imported operators first blows up because the
  operators aren't available on the Observable.

  Another approach is to import the Observable operators directly and call them individually on the Observable. Let's
  update your filtered heroes component to use direct imports.

+makeExcerpt('src/app/heroes-filtered.component.2.ts (direct operator imports)', '')

:marked
  This approach has no side-effects as you're not patching the Observable prototype. It also is
  more conducive to tree shaking versus patching the Observable prototype, which can't be tree-shaken. You're also only importing what you need where you need it,
  but this approach doesn't give you the option to chain operators together.

.l-sub-section
  :marked
    If you are building a third-party Angular library, this would be the recommended approach as you don't want your library to produce any side-effects
    to the Observable for consumers of your library.

:marked
  The recommended approach is to import the operators in the file where you use them. Yes, this may lead to
  duplicate imports of operators in multiple files, but more importantly this ensures that the operators
  that are needed are provided by that file. This becomes especially important with lazy loading, where
  certain feature areas may only make use of certain operators. Importing the operators this way ensures
  the operators are available regardless of where and when you use them.

h3#managing-subscriptions Managing Subscriptions

:marked
  Observables like any other instance use resources and those resources add to the overall weight of your application over time. Observables
  provide a `Subscription` for each `Subscriber` of the Observable that comes with a way to _unsubscribe_ or clean up any resources used
  while listening for values produced by the Observable. We'll look at a simple example of how to unsubscribe from and Observable once
  its no longer needed.

  We'll create a component named `HeroCounterComponent` that will do a simple task of increasing a total of heroes. We'll simulate
  that this hero counter is running as long as the component is active in the view. Once the component is destroyed, we no longer
  want to listen for any changes coming from the Observable counter.

+makeExcerpt('src/app/hero-counter.component.1.ts', 'counter-unsubscribe')

:marked
  Since you know Angular has lifecycle hooks, we can use the `ngOnDestroy` lifecycle hook to unsubscribe from this Observable counter
  and clean up its resources.

+makeExcerpt('src/app/hero-counter.component.1.ts', 'ngOnDestroy-unsubscribe')

:marked
  Disposing of a single subscription when your component is destroyed is very manageable, but as you use more Observables managing
  multiple subscriptions can get unwieldy. We can use a better approach to managing subscriptions. Observables have `operators`
  that can cancel other observable streams. We can end multiple observable streams with one observable using the `takeUntil` operator.
  The `takeUntil` operator takes an Observable and when that observable emits a value, the Observables that are producing values will
  stop emitting values and complete.

  Let's update our hero counter example to use the `takeUntil` operator. In order to use the `takeUntil` operator, we must add it
  to the base Observable prototype. We'll import the operator which will add it to the observable.

+makeExcerpt('src/app/hero-counter.component.ts', 'takeUntil-operator')

:marked
  Since we need an Observable that emits a value, we can use a `Subject`. We'll cover streams you can create on your own later in
  the chapter, as a `Subject` is a special type of Observable.

+makeExcerpt('src/app/hero-counter.component.ts', 'import-subject')

:marked
  You'll need to create an `onDestroy$` observable using the Subject.

+makeExcerpt('src/app/hero-counter.component.ts', 'onDestroy-subject')

:marked
  Now we can add the `takeUntil` operator to our Observable and once the `onDestroy$` Observable completes,
  the counter Observable will complete and will no longer produce any values. This approach scales and you can use a single observable
  to trigger completion across multiple subscriptions.

+makeExcerpt('src/app/hero-counter.component.ts', '')

h3#async-pipe Async Pipe: Declarative Subscription Management
:marked
  You can manage Observables imperatively through manually subscribing and unsubscribing when needed but you can also
  manage them declaratively in our templates using the `Async Pipe`. The async pipe can also take care of our Subscription
  management, as it can take an Observable or a Promise, listen for its emitted values and will destroy its subscriptions
  with the disposing of the component. This allows us to use Observables with less boilerplate and that's a good thing.

  You will create another component that displays a list of heroes using these two options. Our component will retrieve a list of
  Heroes from our `HeroService` and subscribe to set them to a variable in the component.

+makeExcerpt('src/app/hero-list.component.1.ts (subscribe)', '')

:marked
  As you can see, we called and subscribed to the `getHeroes` function in our HeroService which returned an Observable provided
  by the HTTP client and the `ngFor` directive is set up to display the heroes. In the `subscribe` function we assign the returned heroes to the heroes variable.
  Here you are only assigning the `heroes` value to bind it to our template. The `Async Pipe` lets us skip the manual subscription,
  as it will handle this for you. The updated template is below.

+makeExcerpt('src/app/hero-list.component.2.ts (async pipe)', 'async-pipe')

:marked
  You will also update the `heroes` variable and name it `heroes$`, with the **$** denoting that its an Observable value. Its also
  necessary to update the type from `Hero[]` to `Observable<Hero[]>` since the Observable is being passed directly to the template.

+makeExcerpt('src/app/hero-list.component.2.ts (observable heroes)', 'observable-heroes')

:marked
  When your component is rendered, the async pipe will subscribe to the Observable to listen for emitted values. Once the values
  are produced it will bind those values to the same `ngFor` directive. If you were to initiate another sequence of heroes
  the pipe would handle updated the retrieved values along with destroying the Observable subscription once the component is destroyed.

h3#sharing-data Sharing data with a stream
:marked
  As you build out your Angular application, you will start sharing data between multiple components. These components may span across multiple routes
  or application views in your application hierarchy. This allows you to centralize where that data comes from and allow multiple recipients of
  that data to handle it according to their needs. With Observables, you can push changes to this data and notify all of the subscribers so they can react
  to it.

  You will need a simple message bus provided by a service to aggregate events to share across multiple components. The name of your service will be
  aptly named `EventAggregatorService`. Since you want your Observable subscribes to all get the "latest" value from the stream, you'll use a `BehaviorSubject`.

  A `BehaviorSubject` is a special type of Observable that has a memory of the current value or the last value produced, so each new subscriber of this Observable
  will get its current value immediately.

  You'll import the `Injectable` decorator from `@angular/core` and the `BehaviorSubject` from the RxJS library to use it in the service.

+makeExcerpt('src/app/event-aggregator.service.ts (event interface)', 'imports')

:marked
   You'll need an interface to provide consumers with to add messages to the event log.

+makeExcerpt('src/app/event-aggregator.service.ts (event interface)', 'event-interface')

:marked
   Next, you'll create your service. Since a `BehaviorSubject` keeps the latest value for subscribers, you'll need to provide it with an initial value also.
   There is the `add` method for adding additional events to the log and `clear` method for clearing the message. You'll notice that the `notify` method
   calls the `events$.next` method to notify the subscribers of a new value pushed to the stream.

+makeExcerpt('src/app/event-aggregator.service.ts', '')

:marked
  Now that you have a central place to collect events, you can inject the `EventAggregatorService` throughout your application. In order to display
  the message log, you'll create a simple message component to display the aggregated events. You can use the `Async Pipe` here also to wire up the
  stream to the template.

+makeExcerpt('src/app/message-log.component.ts (message log component)', '')

:marked
   As with other services, you'll import the `EventAggregatorService` and `MessageLogComponent` and add it to the `AppModule` providers and declarations
   arrays respectively.

:marked
  To see your message bus in action, you'll import and inject the `EventAggregatorService` in the `AppComponent` and add an event when the Application
  starts and add the `message-log` component to the `AppComponent` template.

+makeExcerpt('src/app/app.component.ts (message log)', '')

h3#error-handling Error Handling
:marked
  As often as you strive for perfect conditions, errors will happen. Servers go down, invalid data is sent and other issues cause errors to happen
  when processing data. While you can do your best to prevent these errors, its also wise to be ready for them when they do happen. The scenario
  this is most likely to happen in is when you're making data requests to an external API. This is a common task done with the Angular HTTP client.
  The HTTP client provides methods that return requests as Observables, which in turn can handle errors. Let's simulate a failed request in your in the `HeroService`.

+makeExcerpt('src/app/hero.service.2.ts (failed heroes)', 'getHeroes-failed')

:marked
  This is what the `HeroListComponent` currently looks like with no error handling and the simulated error.

+makeExcerpt('src/app/hero-list.component.3.ts (failed heroes)', '')

:marked
  With this current setup, you have no way to recover and that's less than ideal. So let's add some error handling with the `catch` operator. You need
  to import the `catch` operator. The `catch` operator will continue the observable sequence even after an exception occurs. Since you know that each
  Observable operator returns a new Observable, you can use this to return an empty array or even a new Observable HTTP request.

  You'll also import the `of` operator, which lets you create an Observable sequence from a list of arguments. In this case, you're returning an empty array
  of `Heroes` when an error occurs.

+makeExcerpt('src/app/hero.service.2.ts (catch and return)', '')

:marked
  Now we have a path of recovery. When the `getHeroes` request is made and fails, an error notification is produced, which will be handled
  in the `catch` operation. This error handling is simplified, so returning an Observable with an empty array will suffice.

h3#retry Retry Failed Observable
:marked
  This is a simple path of recovery, but we can go further. What if you also wanted to _retry_ a failed request? With Observables, this is as easy as adding a new operator,
  aptly named `retry`. If you've ever done this with a Promise, its definitely not a painless operation.

  Of course you'll need to import the operator first.

+makeExcerpt('src/app/hero.service.3.ts (retry operator)', 'retry-import')

:marked
  You can add the `retry` operator to the Observable sequence. The retry operator takes an argument of the number of times you want to retry the sequence before completing.

+makeExcerpt('src/app/hero.service.3.ts', '')

:marked
  The `retry` operator will re-subscribe to the source Observable, in this case is the Observable returned by the `http.get` method. Instead of failing on the
  first error produced by the Observable, now the request will be attempted 3 times before giving up and going into the error sequence.

// TODO Diagram for retry sequence

h3#stream-integration Stream Integration
:marked
  Knowing Angular provides multiple Observables through different APIs is good, but putting those
  streams together in a valuable way is what you will be striving for. With a consistent interface
  provided by Observables, its easy to combine streams together. Let's look at building
  a form to add a Hero to your existing list. When adding a Hero, you'll want to check to see if the hero
  name is available before adding the hero, as well as checking validation while the form is being filled out.
  These definitely sound like streams of data we can tap into.

  Let's start by adding a hero form component that uses a `Reactive Form`. You'll begin with a simple
  form template to enter and save the new hero.

+makeExcerpt('src/app/add-hero.component.1.ts (hero form component)', '')

:marked
  And the hero form template.

+makeExcerpt('src/app/add-hero.component.1.html (hero form template)', '')

:marked
  You'll need to add a new method to the `HeroService` for adding a new hero. As mentioned earlier, the HTTP client returns an Observable
  `Response` that you can use the process the request and operate on if needed. You'll add this request to the `AddHeroComponent` when
  ready to save the hero data.

+makeExcerpt('src/app/hero.service.4.ts (add hero)', '')

:marked
  If you look at the template, you'll see the `showErrors` boolean, which hides the error messages until you're ready to display them.
  A good form waits until the user has interacted with the fields before displaying any errors, and you'll want to follow that same rule. So
  how can you display errors once an interaction has happened? Interaction on the input can be as simple as entering the field
  and leaving the field, also known as the blur event. Observables can be created from existing events. You'll use the `fromEvent`
  operator to create an Observable from the existing `blur` event on the hero name input field.

  In order to access the input field, you'll need to add a template reference to to the element. The `heroName` template reference will
  give us access to the input field in the component class. The updated template is as follows:

+makeExcerpt('src/app/add-hero.component.2.html (heroName template reference)', '')

:marked
  Now that you can access the template reference, you'll need to import the `ViewChild` decorator, the `ElementRef` type
  and the `AfterViewInit` lifecycle hook.

+makeExcerpt('src/app/add-hero.component.2.ts (ViewChild imports)', 'viewchild-imports')

:marked
  You'll use the `ViewChild` decorator to target the `heroName` template reference in the component assigned to
  the `ElementRef` type.

+makeExcerpt('src/app/add-hero.component.2.ts (ViewChild ElementRef)', 'viewchild-heroName')

:marked
  As usual, you'll need to import a few instance and static operators to create the Observable event. As
  previously mentioned, you'll use the `takeUntil` operator to clean up any Observable streams once the component
  is destroyed. In order to create an Observable from an element event, the `fromEvent` observable creation operator
  is needed. The `fromEvent` let's you create a stream from existing events emitted by elements. An additional operator
  is the `merge` creation operator, which combines multiple streams together

+makeExcerpt('src/app/add-hero.component.2.ts (rxjs imports)', 'rxjs-imports-1')

:marked
  In order to use the `ViewChild`, you'll need to implement the `AfterViewInit` interface and the `ngAfterViewInit`
  lifecycle hook. The `Observable.merge` let's you compose multiple observables and will emit when any of the source
  Observables emit a value without waiting for each one. You'll subscribe to the Observable and check the validity of
  the form in order to show errors. Now when the user triggers the `blur` event on the input the errors will be displayed.

+makeExcerpt('src/app/add-hero.component.2.ts (Observable fromEvent)', '')

:marked
  Since you can compose multiple streams using `Observable.merge`, you can easily add additional streams to trigger
  the validation check. Since reactive forms provide an Observable of `valueChanges`, you can listen for value changes
  from the `name` field and display errors once the user inputs some data also. You can easily access this through the reactive
  forms getter. Update the merged observables to include the name valueChanges.

+makeExcerpt('src/app/add-hero.component.3.ts (Observable valueChanges)', 'value-changes')

h3#further-reading Further Reading
:marked
  // TODO link some resources
